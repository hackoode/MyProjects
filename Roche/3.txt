/*@!Encoding:1252*/
includes
{
  //include<'BasicCom.can'>
}

variables
{
  byte request_data[2]={0x10,0x01};
  int can_format; //0- if standard (ex: 0x743), 1- if extended Ex: 0x1C400057x
  long handle;
  char sendString[100];
  long extIdFlag;
  int     g_debug = 0;
  char testStepName[200];
  char buffer[100];
  int protocol;
  int frame_length;
  int positiveResponseLength;
  int Byte_Position;
  byte Byte_value;
  char Bits_Evaluation[8];
  int Start_value;
  int End_value;
  Char Bytes_value[8194];
  int Security;
  char g_Key_Request[50];
  char g_Key_Response[50];
  char g_Security_Key[2050];
  char operator[2];
  message can1.0x18DAB0F1x DiagnosticRequest = {dlc = 8};
  message can1.0x18DAF1B0x DiagnosticResponse = {dlc = 8};
	//- -
	//! \brief  Global variable stores the size of the transmitted message
	//!
	//! \type int type variable
	//- -
  int     ByteSize;
  int security_Access_type_1;
  int security_Access_type_2;
  int security_Access_type_5;
  int security_Access_type_4;
	//- -
	//! \brief  Global variable stores the service ID of the diagnostic message
	//!
	//! \type int type variable
	//- -
  int     SID;

	//- -
	//! \brief  Global variable to store the value of a signal so it could be restored later.
	//!
	//! \type int type variable
	//- -
  long     StoredSignalValue;

	//- -
	//! \brief  Global variable to store the bus context.
	//!
	//! \type dword type variable
	//- -
  dword     StoredBuxContext;

	//- -
	//! \brief  Global variable stores the arrived response bytes in string variable
	//!
	//! \type char array type variable
	//- -
  char    byteString[8194];

	//- -
	//! \brief  Global variable to save the previously received response
	//!
	//! \type char array type variable
	//- -
  char    seedString[8194];

	//- -
	//! \brief  Global variable to save the previously received response in byte format
	//!
	//! \type byte array type variable
	//- -
  byte    seedData[8194];

	//-
	//! \brief  Global variable to store a timestamp. \n
	//!			E.g., this is used in the <em> <b> TimeNowStart </b> </em> testcase.
	//!
	//! \type Float type variable.
	//-
	float   tMesStart;

  //-
	//! \brief  Global variable to store a time value. \n
	//!
	//! \type Float type variable.
	//-
	float   timeValue;

  //-
	//! \brief  Global array to store any char type information. \n
	//!
	//! \type Char array type variable.
	//-
	char   tempArray[8194];

	//- -
	//! \brief  Global variable to save the count of received message bytes
	//!
	//! \type long type variable
	//- -
	long    ResponseLength = 0;

	//- -
	//! \brief  Global variable for the transmitted message
	//!
	//! \type byte array type variable
	//- -
  byte    RqTxData[32767];
  byte TxDataBuffer[32767];

	//- -
	//! \brief  Global variable to store the actual transmitted message in string type
	//!
	//! \type char array type variable
	//- -
  char    RqTxStringData[32767];
  char    RqRs_withspace[32767];
  char    Rs_withspace[32767];
	//- -
	//! \brief  Global variable for the received message
	//!
	//! \type byte array type variable
	//- -
   byte    RsRxIntData[32767];//81940

	//- -
	//! \brief  Global variable to store the actual received message in string type
	//!
	//! \type char array type variable
	//- -
   char    RsRxStringData[32767];

	//- -
	//! \brief  Global variable to store the actual received message in string type
	//!
	//! \type char array type variable
	//- -

   long g_rxId  ;
   long g_txId_PhysicalAddr  ;
   long g_txId_FunctionalAddr;
   long handle_testS;
   long handle_funcS;
   long handle_testPresent;
   long gWaitingHandle;
    //long currentConnHandle;
   byte flagOfCF=0;
   byte TxLength = 0;
   long ext_Id = 0x80000000 ;
    //long handle_response;
  //const int TesterPresentTime = 1000;


}

////- -----------------------------------------------------------------------------------------------
//
export testfunction TF_CloseTPConnection()
{
  CanTpCloseConnection( handle );
}

export testfunction TF_WriteSystemVariable_CAN(char Signal_Name[],Double signal_value)
{
  setRawSignal(Signal_Name,signal_value);
}
/*This function is called from Test Design to create handle for TP and initialize TX ID,RX ID,Addressing Mode,Protocol,
Frame Length and Message Format*/


export void  initialize_CanMsgId(char Request[], char Response[], char CompareMode[], long rxId, long p_txId, long f_txId, char AddressingMode[], int proj_protocol, int proj_frame_length, int extended_format )
{
    /* CompareMode is an extension for being able to check whether the response contains the Response as substring */
    /* values: Equal  - Response has to match with the whole response                                                   */
    /*         Regexp - Response can be a substring of the response                                                     */
    /*         None   - it is expected that the response does not contain Response as substring                         */
  //CanTpCloseConnection( handle_funcS );
  //CanTpCloseConnection( handle );
  can_format = extended_format;
  handle = CanTpCreateConnection(0);
  g_txId_FunctionalAddr = f_txId;
  g_txId_PhysicalAddr = p_txId;
  g_rxId = rxId;
  
  if( handle==0)
  {
   TestStep("INFO","No handle present for physical addressing");
  }


  if (proj_frame_length != 0)
  {
    frame_length = proj_frame_length;
  }
  else
  {
    frame_length = 8;
    TestStep("INFO","Please give a Valid Frame Length for your Project");
  }
  if (proj_protocol == 0)
  {
    protocol = 0;
    TestStep("INFO","Protocol: Sending a CAN Standard  Frame");
  }
  else if (proj_protocol ==1)
  {
    protocol = 1;
    TestStep("INFO","Protocol: Sending a CANDFD Frame");
    CanTpSetMaxCANFDFrameLength( handle, frame_length);
    CanTpSetBitRateSwitch( handle, protocol);//set to can FD
  }



// Check whether is the rxId and the txId is empty (empty = 0)

  if(rxId == 0 && p_txId ==0 && f_txId == 0)
  {
    TestStep("INFO","Please enter valid Tx and Rx IDs");
     //setType (rxId, txId, handle_testS);
  }
  else
  {
   if (0 == strncmp("1",AddressingMode,strlen(AddressingMode)))
      {


            CanTpCloseConnection( handle );
            handle_funcS = CanTpCreateConnection(0);
            CanTpSetAddressType( handle_funcS, 1);

        setType(g_rxId,g_txId_FunctionalAddr,handle);

        RequestResponseCompareLogic(Request, Response, CompareMode, "Functional");
      }
   else
      {

        CanTpSetAddressType( handle, 0);
        setType (g_rxId,g_txId_PhysicalAddr,handle);

        RequestResponseCompareLogic(Request, Response, CompareMode, "Physical");
      }
  }


}


export testfunction TF_OpenTPConnection(char Request[], char Response[], char CompareMode[], long rxId, long p_txId, long f_txId, char AddressingMode[], int proj_protocol, int proj_frame_length, int extended_format )
{
  initialize_CanMsgId(Request,Response,CompareMode,rxId,p_txId,f_txId,AddressingMode,proj_protocol,proj_frame_length,extended_format);
}

//- -----------------------------------------------------------------------------------------------

/*This function is called internally to set type as Extended or Standard CAN ID's*/


void setType(long rxId, long txId, long handle)
{

// TODO:   Check if the rxId an txId is a valid hex format

//They will be from now the message IDs in CAN

  if (can_format > 0)
  {
    write("extended CAN IDs");
    CanTpSetRxIdentifier( handle, (ext_Id | rxId));
    CanTpSetTxIdentifier( handle, (ext_Id | txId));//set extended message
  }
  else
  {
    write("Standard can IDs");
    CanTpSetRxIdentifier( handle,  rxId);
    CanTpSetTxIdentifier( handle, txId);//set standard message IDs
  }
}

//- -----------------------------------------------------------------------------------------------

/*This function is called from Test Function or internally for sending Diag Request with Address Mode as Physical or Functional and when 
Response is received Comparison is done with Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed */

export int RequestResponseCompareLogic(char Request[], char Response[], char CompareMode[], char AddressingMode[])
{
    byte responsePending;
    long result;
int index1,index2;
dword RN4H, RN4L;
dword Keyw,Saved_Key,tempkey1,tempkey2,tempkey3,tempkey4,tempkey5,seed;
    long timeOutValue;
    int numberRPs;
    int getData;
    int i = 0;
    long ext_Id = 0x80000000;  
int SC4 = 0xD9;
seed=0;
Keyw=0;
tempkey1=0;
tempkey2=0;
tempkey3=0;
tempkey4=0;
tempkey5=0;
  

    responsePending = 0;
    numberRPs = 0;
    timeOutValue = 5500;
  if( CompareMode[0] == 'S' && CompareMode[1] == 'u' )
  {
    timeOutValue = 1000;
  }
 
	//check the validity of the compare mode

    //write("handle_test is %d", currenthandle_test);
    if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode))
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))
      || 0 == strncmp("Length", CompareMode,strlen(CompareMode)) || 0 == strncmp("Bits_Evaluation", CompareMode,strlen(CompareMode)) || 0 == strncmp("Byte_Evaluation", CompareMode,strlen(CompareMode))|| 0 == strncmp("Bytes_Evaluation", CompareMode,strlen(CompareMode)) || 0 == strncmp("Security_Seed", CompareMode,strlen(CompareMode)) 
      || 0 == strncmp("Security_Key", CompareMode,strlen(CompareMode))))
	  {
		    TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
        TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
		    return 0;
  	}
  	else
	  {
  //    CanTpSendData(handle, RqTxData, ByteSize);
  		//The compare mode is valid
  		 if((0 == str_match_regex(Request, " {1}")) || (0 == str_match_regex(Request, " {1}")) )
       {
          TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
          strncpy(RqRs_withspace, Response, elCount(Response));
          str_replace_regex(Request, " ", "");
          str_replace_regex(Response, " ", "");
  	   }
  		
  //    else{
  //     CharArraywithspace(Request); 
  //		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", RqRs_withspace, CompareMode);
  //    }
      
      CharArray2Byte(Request); // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
      
  	  if (0 == strncmp("Physical",AddressingMode,strlen(AddressingMode)) || 0 == strncmp("0",AddressingMode,strlen(AddressingMode)))
      {
          if (handle == 0)
          { TestStep("INFO","No handle present for physical addressing");
          handle = CanTpCreateConnection(0);
          }
          else
          {
            //write("%x",g_rxId); write("%x",g_txId_FunctionalAddr); write("%x",g_txId_PhysicalAddr);
            if(security_Access_type_1 ==1)
            {
              ByteSize =4;
              security_Access_type_1 =0;
            }
            if(security_Access_type_2 ==1)
            {
              ByteSize =2050;
              security_Access_type_2 =0;
            } 
            if(security_Access_type_4 ==1)
            {
              ByteSize =7;
              security_Access_type_4 =0;
            } 
            
            if(security_Access_type_5 ==1)
            {
              ByteSize =6;
              security_Access_type_5 =0;
            }             
            CanTpSendData(handle, RqTxData, ByteSize);
              TestStep("INFO","Entered the Physical addressing");
          }
      }
      else if (0 == strncmp("Functional",AddressingMode,strlen(AddressingMode)) || 0 == strncmp("1",AddressingMode,strlen(AddressingMode)))
      {
          TestStep("INFO","Entered the Functional addressing");
          //CanTpCloseConnection(handle);
          handle_funcS = CanTpCreateConnection(0);
          if (protocol == 0)
          {
           TestStep("INFO","Protocol: sending a CAN standard frame");
          }
          else if (protocol ==1)
          {
            CanTpSetMaxCANFDFrameLength( handle_funcS, frame_length);
            CanTpSetBitRateSwitch( handle_funcS, protocol);//set to can FD
          }
          setType(g_rxId,g_txId_FunctionalAddr, handle_funcS);
          CanTpSetAddressType( handle_funcS, 1); // functional

          CanTpSendData(handle_funcS, RqTxData, ByteSize);
          CanTpCloseConnection( handle_funcS );
         if (handle ==0)
         {
           TestStep("INFO","No handle present for Functional addressing");
         }
         setType(g_rxId,g_txId_PhysicalAddr, handle);

      }

       		//START check the response from the ECU:
  		do
  		{
  			//Wait for the message from the ECU
        responsePending = 0;
  			if(ResponseLength < 5000)
  			{
  				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);      
  			}
  			else if(ResponseLength < 10000)
  			{
  				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*2);
  			}
  			else
  			{
  				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*3);
  			}
  			if(result == 0)
  			{
          //If no response is received
  				return responseMatching(CompareMode, Response, numberRPs, "Noresponse", result,0);
  			}
  			else if(result == 1)
  			{
          //If response is received
  				//Negative branch starts
			/*		if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID )
  				{ */
  				if( RsRxIntData[0] == 0x7f)
  				{
            if(RsRxIntData[1] == SID)
            {
              if( RsRxIntData[2] == 0x78 )
              {
                
                TestStep("INFO","Response Pending received from ECU");
    						responsePending = 1;
    						numberRPs++;
    						timeOutValue = 5500;
  					  }
  					  else
  					  {

                //TestStep("INFO","Negative Response from ECU!");
  						  return responseMatching(CompareMode, Response, numberRPs, "NRC", result,0);
  					  }
            }
  				}
  				//Positive branch starts
  				if( RsRxIntData[0] == (SID + 0x40) )
  				{
            if (positiveResponseLength !=0)
            {
//              if(RsRxIntData[0] == 0x67 && RsRxIntData[1] == 0x41)
//              {
//                if(RsRxIntData[6]==0x00)
//{
//  RsRxIntData[6]=RsRxIntData[6]+0x23;
//}
//                if(RsRxIntData[5]==0x00)
//{
//  RsRxIntData[5]=RsRxIntData[5]+0x23;
//}
//                if(RsRxIntData[4]==0x00)
//{
//  RsRxIntData[4]=RsRxIntData[4]+0x23;
//}
//                if(RsRxIntData[3]==0x00)
//{
//  RsRxIntData[3]=RsRxIntData[3]+0x23;
//}
//
// seed = ((RsRxIntData[6] & 0x000000FF) | ((RsRxIntData[5] & 0x000000FF) << 0x08) | ((RsRxIntData[4] & 0x000000FF) << 0x10) | ((RsRxIntData[3] & 0x000000FF) << 0x18));
//   // write("%X",seed);
//    
//    tempkey1 = (seed + 0xAEFC2A98);
//
//    tempkey2 = ((tempkey1 << 1) | (tempkey1 >> (0x20 - 1)));
//    tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));
//    tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));
//
//    tempkey3 = ((seed >> 1) | (seed << (0x20 - 1)));
//
//
//    tempkey4 = tempkey2 ^ tempkey3;
//    
//    RN4H = ((seed & 0xFFFF0000) >> 0x10);
//
//    RN4L = (seed & 0x0000FFFF);
//
//    tempkey5 = (RN4H * RN4L);
//
//    Keyw =((tempkey4 ^ tempkey5) + 0x00703714);
//    RqTxData[0]=0x27;
//    RqTxData[0]=0x42;
//    RqTxData[2] = ((Keyw & 0xFF000000) >> 0x18);
//    RqTxData[3] = ((Keyw & 0x00FF0000) >> 0x10);
//    RqTxData[4] = ((Keyw & 0x0000FF00) >> 0x08);
//    RqTxData[5] = (Keyw & 0x000000FF);
//    RqTxData[6] = 0xEA;
//    write("i am inside security");
//          CanTpSendData(0, RqTxData, 7);
//          CanTpCloseConnection( 0 );
//               }
              return responseMatching(CompareMode, Response, numberRPs, "response", result,positiveResponseLength);
            }
            else
            {
              //TestStep("INFO","Positive Response from ECU!");
  					  return responseMatching(CompareMode, Response, numberRPs, "response", result,0);
            }
  				}
  			}
        
  		}while( (responsePending == 1) && (numberRPs < 24) );
       //Pending response handling


  		if( responsePending == 1 )
  		{
  			TestStepFail("INFO","Timeout while waiting for diag response!");
  			return 0;
  		}

      //CanTpCloseConnection( handle_test );
  	}
}


on busOff
{
  int errRxCnt;
int errTxCnt;
int channel;
double timestamp; // [seconds]

timestamp = (double)timeNow() / (double)100000;
channel = this.can;
errRxCnt = this.errorCountRX;
errTxCnt = this.errorCountTX;
Write("Bus Off: time=%f channel=%d, errRxCnt=%d, errTxCnt=%d",
timestamp, channel, errRxCnt, errTxCnt);

resetCanEx(channel);

}
//- -----------------------------------------------------------------------------------------------

/*This function is called from Test Function for Security Access*/

export void RequestSecurityAccess(char Seed_Request[], char Seed_Response[],char Key_Request[], char Key_Response[], int Security_Level, char AddressingMode[])
{
  long result;
  char Request[30],Request_withspace[60];
  int i, j, k;
  strncpy(g_Key_Request,Key_Request,elcount(Key_Request));
  strncpy(g_Key_Response,Key_Response,elcount(Key_Response));
  Security = Security_Level;
  result=RequestResponseCompareLogic(Seed_Request,Seed_Response,"Security_Seed",AddressingMode);
 
  if (result == 1)
  {
    if (Security == 1)
    {
   
      Calculate_Security_Level_Key_1();
    }
    if (Security == 2)
    {
    
      Calculate_Security_Level_Key_2();
    }   
    if (Security == 4)
    {
   
      Calculate_Security_Level_Key_4();
    }
    if (Security == 5)
    {
    
      Calculate_Security_Level_Key_5();
    } 
  
    str_replace_regex(Key_Request, " ", "");
    j=0;
    strncat(Key_Request,g_Security_Key , (strlen(Key_Request)+strlen(g_Security_Key))+1);
    strncpy (Request,Key_Request,elcount(Request));
    for (i = 0; i < strlen(Request); i++)
     {
        if (i%2 ==1)
        {
          Request_withspace[j] = Request[i];
          Request_withspace[j+1] = ' ';
          j+=2;
        }
        else
        {
          Request_withspace[j] = Request[i];
          j++;
        }
    }
    toUpper(Request_withspace, Request_withspace, elcount(Request_withspace));
    result=RequestResponseCompareLogic(Request_withspace,Key_Response,"Security_Key",AddressingMode);
    //TF_XCP_to_Read("XCP::RadarFC::_g_FCT_mainProc_mainProc::_m_stateMachines::_m_acuteWarningStateMachine::StateMachine","_m_currentState", 2);
    }
  
}

/*This function is called from Design for Security Access*/
export testfunction TF_RequestSecurityAccess(char Seed_Request[], char Seed_Response[],char Key_Request[], char Key_Response[], int Security_Level, char AddressingMode[])
{
  RequestSecurityAccess(Seed_Request, Seed_Response, Key_Request,  Key_Response,  Security_Level,  AddressingMode);
}

//- -----------------------------------------------------------------------------------------------

/*This function is called Internally for calculating Security Access Level 1*/

void Calculate_Security_Level_Key_1()
{
  
char output[301];
int index;
char al[3];
char tmp_var[4]; 
dword SK1, SK2, SK3;
dword Keyw,tempkey1,tempkey2,seed;

seed=0;
Keyw=0;
al[0]='0';al[1]='0';al[2] ='0';
SK1=0xCC91;
SK2=0x3776;
SK3=0xC03F;
if((RsRxIntData[0]== 0x67))
  {
    if (RsRxIntData[1]== 0x01) 
    {

    seed = ((RsRxIntData[3] & 0x000000FF) | ((RsRxIntData[2] & 0x000000FF) << 0x08));
    tempkey1 = (seed + SK1);
    tempkey2 = ((seed * SK2) % SK3);
  
 // write("%X %X %X %X",seed,SK1,SK2,SK3);
    Keyw = (tempkey1 ^ tempkey2);
   
    RqTxData[0] = ((Keyw & 0x0000FF00) >> 0x08);
    RqTxData[1] = (Keyw & 0x000000FF);
    RqTxData[2]=0x00 ;
    RqTxData[3]=0x00; 
    RqTxData[4]=0x00 ;
    RqTxData[5]=0x00 ; 
    RqTxData[6]=0x00;
    RqTxData[7]=0x0 ;
    RqTxData[8]=0x0 ;
    RqTxData[9]=0x0 ;
    write("RqTxData data = %x,%x",RqTxData[0],RqTxData[1]);
  
  output[0]=0;
  for (index=0;index<2;index++)
   {
    snprintf(tmp_var,elCount(tmp_var),"%.2X",RqTxData[index]);
    write(" length of tmp_var = %d, value of tmp_var =%s",elCount(tmp_var),tmp_var);
    strncat(output,tmp_var,elCount(output));
    write(" length of output = %d, value of output =%s",elCount(output),output);
  }
  
//Below variable is set to consider byte size to 4 ,otherwise by default size will be considered as 6
  security_Access_type_1 =1;
  strncpy(g_Security_Key,output,elCount(output));

  write("length of g_Security_Key = %d,g_Security_Key data = %s,tmp_var = %s, output = %s",elCount(g_Security_Key),g_Security_Key,tmp_var,output);
    }
  }
}
void Calculate_Security_Level_Key_2()
{

char out[2050];
int i;
char tmp[6];
qword temp1;
qword temp2;
byte seedArray[6];
byte keyBuffer[2048];  
  
  for(i=0;i<2048;i++)
  {
    keyBuffer[i]=0;
  }
  temp1=0;temp2=0;  

    if (RsRxIntData[0]==0x67)
    {
     if (RsRxIntData[1]==0x61) 
    {

    
  seedArray[0]= RsRxIntData[2];
  seedArray[1]= RsRxIntData[3];
  seedArray[2]= RsRxIntData[4];
  seedArray[3]= RsRxIntData[5];
  seedArray[4]= RsRxIntData[6];
  seedArray[5]= RsRxIntData[7]; 
  temp1 = seedArray[0];
  seedArray[0] = seedArray[5];
  seedArray[5] = temp1;
  temp1 = seedArray[1];
  seedArray[1] = seedArray[4];
  seedArray[4] = temp1;
  temp1 = seedArray[2];
  seedArray[2] = seedArray[3];
  seedArray[3] = temp1;
  write("value of temp1 init = %x ,value of temp2 init= %x",temp1,temp2);
  temp1 = ((seedArray[0] << 8) | seedArray[1]);
  temp2 = ((seedArray[2] << 24) | (seedArray[3] << 16) |(seedArray[4] << 8) | (seedArray[5])) ;
  temp2 = ((temp2 >> 1) | ((temp1 & 0x1) << 31));
  temp1 = (temp1 >> 1);
   write("value of temp1 = %x ,value of temp2 = %x",temp1,temp2);
   // Fill in the key.
   keyBuffer[0] = (temp1 >> 8) & 0xFF;
   keyBuffer[1] = (temp1  & 0xFF);
   keyBuffer[2] = (temp2 >> 24) & 0xFF;
   keyBuffer[3] = (temp2 >> 16) & 0xFF;
   keyBuffer[4] = (temp2 >> 8) & 0xFF;
   keyBuffer[5] = (temp2 & 0xFF);
  RqTxData[0] = keyBuffer[0];
  RqTxData[1] = keyBuffer[1];
  RqTxData[2] = keyBuffer[2];
  RqTxData[3] = keyBuffer[3];
  RqTxData[4] = keyBuffer[4];
  RqTxData[5] = keyBuffer[5]; 

  write("%x ,%x",keyBuffer[0],keyBuffer[1]);       
                     

  out[0]=0;
  i=0;
  for (i=0;i<6;i++)
   {
    snprintf(tmp,elcount(tmp),"%.2X",keyBuffer[i]);
    strncat(out,tmp,elcount(out));
    write("size of out =%d,value of out =%x",elCount(out),out);
   }
  
  strncpy(g_Security_Key,out,elcount(out));
  write("size of g_Security_Key =%d,value of g_Security_Key =%s",elCount(g_Security_Key),g_Security_Key);
  security_Access_type_2 =1;
    }
   }

}
void Calculate_Security_Level_Key_4()
{
 
dword RN4H, RN4L;
  qword Keyw,Saved_Key,tempkey1,tempkey2,tempkey3,tempkey4,tempkey5,seed;
    long timeOutValue;
    int numberRPs;
    int getData;
    char tmp[8];
    char out[301];
    int i = 0;
    long ext_Id = 0x80000000;  
int SC4 = 0xD9;
seed=0;
Keyw=0;
tempkey1=0;
tempkey2=0;
tempkey3=0;
tempkey4=0;
tempkey5=0;             
  
  if((RsRxIntData[0]== 0x67))
  {
    if (RsRxIntData[1]== 0x41) 
    {
      if (RsRxIntData[6]== 0xEA)
              {

          seed = ((RsRxIntData[5] & 0x000000FF) | ((RsRxIntData[4] & 0x000000FF) << 0x08) | ((RsRxIntData[3] & 0x000000FF) << 0x10) | ((RsRxIntData[2] & 0x000000FF) << 0x18));
         // write("%X",seed);
         seed = seed & 0x0ffffffff;
         tempkey1 = (seed + 0xAEFC2A98);
         tempkey1 = tempkey1 & 0x0ffffffff;
         tempkey2 = ((tempkey1 << 1) | (tempkey1 >> (0x20 - 1)));
         tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));
         tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));
         tempkey2 = tempkey2 & 0x0ffffffff;
         tempkey3 = ((seed >> 1) | (seed << (0x20 - 1)));
         tempkey3 = tempkey3 & 0x0ffffffff;

         tempkey4 = tempkey2 ^ tempkey3;
         tempkey4 = tempkey4 & 0x0ffffffff;
         RN4H = ((seed & 0xFFFF0000) >> 0x10);
         RN4H = RN4H & 0x0ffff;
         RN4L = (seed & 0x0000FFFF);
         RN4L = RN4L & 0x0ffff;
         tempkey5 = (RN4H * RN4L);
         tempkey5 = tempkey5 & 0x0ffffffff;
         Keyw =((tempkey4 ^ tempkey5) + 0x00703714);
         RqTxData[0] = ((Keyw & 0xFF000000) >> 0x18);
         RqTxData[1] = ((Keyw & 0x00FF0000) >> 0x10);
         RqTxData[2] = ((Keyw & 0x0000FF00) >> 0x08);
         RqTxData[3] = (Keyw & 0x000000FF);
         RqTxData[4] = 0xEA; 
         write("%x ,%x",RqTxData[0],RqTxData[1]);       
              }         

  out[0]=0;
  for (i=0;i<5;i++)
   {
    snprintf(tmp,elcount(tmp),"%.2X",RqTxData[i]);
    strncat(out,tmp,elcount(out));
   }
  
  strncpy(g_Security_Key,out,elcount(out));
  security_Access_type_4 = 1;
}
  }
}
//- -----------------------------------------------------------------------------------------------

void Calculate_Security_Level_Key_5()
{
dword SC5;
dword Keyw,tempkey1,tempkey2,tempkey3,seed;
char tmp_char [6];
char out_string [300];
int i,j;
seed=0;
Keyw=0;
tempkey1 =0;
tempkey2 =0;
tempkey3 =0;
  

SC5=0xA811;
  if((RsRxIntData[0]== 0x67))
  {
    if (RsRxIntData[1]== 0x07) 
    { 
      if((RsRxIntData[4]== 0xA8))
       {
         if (RsRxIntData[5]== 0x11) 
           { 
 seed = ((RsRxIntData[3] & 0x000000FF) | ((RsRxIntData[2] & 0x000000FF) << 0x08));
  //Algorithm to calculate the key
    if(SC5 == 0xa810)
    {
       
        tempkey1 = (seed ^ 0x1D0B);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0xAD07));
    }

    else if(SC5 == 0xa811)
    {
        
        tempkey1 = (seed ^ 0x9CE7);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x0C87));
    }

    else if(SC5 == 0xa812)
    {
        
        tempkey1 = (seed ^ 0x20C2);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x104D));
    }

    else if(SC5 == 0xa813)
    {
        
        tempkey1 = (seed ^ 0x927C);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x0A8C));
    }

    else if(SC5 == 0xa814)
    {
        
        tempkey1 = (seed ^ 0x1197);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x298F));
    }

    else if(SC5 == 0xa815)
    {
        
        tempkey1 = (seed ^ 0x883A);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x99ED));
    }

    else if(SC5 == 0xa816)
    {
        
        tempkey1 = (seed ^ 0x9D10);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x22A9));
    }

    else if(SC5 == 0xa817)
    {
        
        tempkey1 = (seed ^ 0x210B);
        tempkey2 = (((tempkey1 << 1)) | ((tempkey1 >> (0x10 - 1))));
        tempkey3 = (((tempkey2 << 1)) | ((tempkey2 >> (0x10 - 1))));
        Keyw = ((tempkey3 + 0x39C1));
    }
   
    RqTxData[0] = ((Keyw & 0x0000FF00) >> 0x08);
    RqTxData[1] = (Keyw & 0x000000FF);
    RqTxData[3] = ((SC5 & 0x0000FF00) >> 0x08);
    RqTxData[4] = (SC5 & 0x000000FF);
  i=0;
  out_string[0]=0;
  for (i=0;i<4;i++)
   {
    snprintf(tmp_char,elcount(tmp_char),"%.2X",RqTxData[i]);
    strncat(out_string,tmp_char,elcount(out_string));
   }
  
  strncpy(g_Security_Key,out_string,elcount(out_string));
  security_Access_type_5 =1;
         }
       }
     }
    }
}



/*This function is called from Test Function for checking length of response bytes*/

export void Response_Length_Check(char Request[], char Response[], int Length, char AddressingMode[], char compare_operator[])
{
  long result;
  positiveResponseLength = Length;
  strncpy(operator,compare_operator, elcount(compare_operator));
  result=RequestResponseCompareLogic(Request,Response,"Length",AddressingMode);
}

/*This function is called from design for checking length of response bytes*/

export testfunction TF_Response_Length_Check(char Request[], char Response[], int Length, char AddressingMode[], char length_compare[])
{
  Response_Length_Check(Request,Response, Length, AddressingMode, length_compare);
  testWaitForTimeout(500);
}

//- -----------------------------------------------------------------------------------------------


/*This function is called automatically, when data has been received
on the connection with the given handle. The number of bytes received
is available as length of the byte array.
*/

void CanTp_ReceptionInd(long connHandle, byte data[])
{
  int RIP;
  int i = 0;
  long Ind;
  RIP = SID + 0x40;

//  write("Reception Frame. connHandle: %d", connHandle);
  //write("Received %d byte on connection %d: [%02x] [%02x] ...",
        //elcount(data), connHandle, data[0],data[1]);
  //if(connHandle == handle_testS)
  {
      for(i = 0; i<elcount(data); i++)
      {
        RsRxIntData[i] = data[i];
      }
      //Ind = CanTpCopyDataReceived(1, RsRxIntData, elcount(RsRxIntData));
      ResponseLength = elcount(data);

      if(0x7F == data[0] &&
         0x21 == data[2])
      {
        CanTpSendData(connHandle, RqTxData, ByteSize);
        write("Busy Repeat Request detected -> Repeat last request!");
        write("***********************************************************");
      }
      else
      {
//      else if(0x7F == data[0] &&
//              0x78 == data[2])
//      {
//        CreateByteString(RsRxIntData, 0, elcount(data));
//        TestSupplyTextEvent("TpMsgReceived");
//      }
//      else
//      {
        CreateByteString(RsRxIntData, 0, elcount(data));
        TestSupplyTextEvent("TpMsgReceived");// Indicates the mesage reception and will be used for comparisons
        //CanTpCloseConnection( connHandle );
      }
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that stores the arrived response in the byteString variable.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void CreateByteString (byte response[], long offset,long responseLength)
{
    char intString[4096];
    char catString[10];
    int i=0;
    long dataLength;

    snprintf(byteString, elcount(byteString), "");
    dataLength = responseLength;

    for(i=offset; i < dataLength;i++)
    {
        ltoa(response[i], intString, 16);

        if( 1==strlen(intString) )
        {
            snprintf(catString, elcount(catString), "0");
            strncat(catString, intString, elcount(catString));
            strncpy(intString, catString, elcount(intString));
        }

        strncat(byteString, intString, elcount(byteString));
    }
    toUpper(byteString, byteString, elcount(byteString));
   
    

}

/*This function is called internally to check response is matching or not and print in report PASS or FAIL*/

int responseMatching(char CompareMode[], char Response[], int NumberRPs, char MessageFormat[], long result,int Length)
{
  int i;
  if(result == 1)
	{
    
		TestStep("INFO","EXPECTED RESPONSE: %s", RqRs_withspace);
    for (i=0;i<strlen(Rs_withspace);i++)
    {
      Rs_withspace[i]=' ';
    }
		//CharArraywithspace(byteString);
    TestStep("INFO","RECEIVED RESPONSE: %s", byteString);
    for (i=0;i<strlen(Rs_withspace);i++)
    {
      Rs_withspace[i]=' ';
    }
    result = 0;
		//Message received, Compare mode is equal
		if(0 == strncmp("Equal", CompareMode,strlen(CompareMode)))
		{
			

      if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
			{
				TestStepPass("INFO","Expected %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s received!", MessageFormat);
				return 0;
			}
		}
    //Message received, Compare mode is Length
    else if(0 == strncmp("Length", CompareMode,strlen(CompareMode)))
		{
//			if(positiveResponseLength == ResponseLength)
//			{
//				TestStepPass("INFO","Expected Length %d received!", ResponseLength);
//				return 1;
//			}
//			else
//			{
//				TestStepFail("INFO","Expected Length is %d but Length %d received!", positiveResponseLength,ResponseLength);
//				return 0;
//			}

  if(strncmp(operator,"<=",2))
  {
    if(positiveResponseLength <= ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
  else if(strncmp(operator,">=",2))
  { 
    if(positiveResponseLength >= ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
  else if(strncmp(operator,"==",2))
  { 
    if(positiveResponseLength == ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
  else if(strncmp(operator,"!=",2))
  { 
    if(positiveResponseLength != ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
  else if(strncmp(operator,">",1))
  { 
    if(positiveResponseLength > ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
  else if(strncmp(operator,"<",1))
  { 
    if(positiveResponseLength < ResponseLength)
    {
      testStepPass("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
    else
    {
      testStepFail("","ExpectedValue : %s %d; ObtainedValue = %d",operator, positiveResponseLength,ResponseLength);
    }
  }
    

		}
        //Message received, Compare mode is Bits_Evaluation
    else if(0 == strncmp("Bits_Evaluation", CompareMode,strlen(CompareMode)))
		{
			if(Bits_Evaluation(Byte_Position,Bits_Evaluation) == 1)
			{
				TestStepPass("INFO","Expected Bits %s is Setting in Byte Position %d, received Byte Data %x !", Bits_Evaluation,Byte_Position,RsRxIntData[Byte_Position]);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Expected Bits %s not Setting in Byte Position %d, received Byte Data %x !", Bits_Evaluation,Byte_Position,RsRxIntData[Byte_Position]);
				return 0;
			}
		}
    //Message received, Compare mode is Security Seed
    else if(0 == strncmp("Security_Seed", CompareMode,strlen(CompareMode)))
		{
        if (RsRxIntData[0]==0x67)
        {
          TestStepPass("INFO","Seed %s received!",Rs_withspace);
				  return 1;
        }
        else
        {
          TestStepFail("INFO","Seed is not received!");
          return 0;
        }
		}
     //Message received, Compare mode is Byte_Evaluation
    else if(0 == strncmp("Byte_Evaluation", CompareMode,strlen(CompareMode)))
		{
			if(Byte_Evaluation(Byte_Position,Byte_value) == 1)
			{
				TestStepPass("INFO","Expected Byte %x is Setting in the given Position %d, received Byte Data is %x !", Byte_value,Byte_Position,RsRxIntData[Byte_Position]);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Expected Byte %x not Setting in Byte Position %d, received Byte Data is %x !", Byte_value,Byte_Position,RsRxIntData[Byte_Position]);
				return 0;
			}
		}
     //Message received, Compare mode is Bytes_Evaluation
    else if(0 == strncmp("Bytes_Evaluation", CompareMode,strlen(CompareMode)))
		{
			if(Multiple_Bytes_Evaluation(Start_value,End_value,Bytes_value) == 1)
			{
				TestStepPass("INFO","Expected Bytes %s is Setting in between start postion %d and End Position %d, received Data bytes %s !", Bytes_value,Start_value,End_value,byteString);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Expected Bytes %s is not Setting in between start postion %d and End Position %d, received Data bytes %s !", Bytes_value,Start_value,End_value,byteString);
				return 0;
			}
		}
   //Message received, Compare mode is Security Key
    else if(0 == strncmp("Security_Key", CompareMode,strlen(CompareMode)))
		{
        if (RsRxIntData[0]==0x67)
        {
          TestStepPass("INFO","Seed Access Granted!");
				  return 1;
        }
        else
        {
          TestStepFail("INFO","Seed Access not Granted!");
          return 0;
        }
		}
    //Message received, Compare mode is NotPresent
    else if(0 == strncmp("NotPresent", CompareMode,strlen(CompareMode)))
		{
      int cnt;
	    int idx_hex;
      int counter;
      char temp_cmd[8192];
      int idx_result;
			if(1 == str_match_regex(byteString, Response))
			{
				TestStepFail("INFO","Expected substring is  %s present in the response!", MessageFormat);
				return 1;
			}
      else 
      {
        TestStepPass("INFO","Unexpected %s received!", MessageFormat);
    				return 0;
      }  
    }
		//Message received, Compare mode is regexp
		else if(0 == strncmp("Regexp", CompareMode,strlen(CompareMode)))
		{
      int cnt;
	    int idx_hex;
      int counter;
      char temp_cmd[8192];
      int idx_result;
    
			if(1 == str_match_regex(byteString, Response))
			{
				TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
      else 
      {
          int i;
          long idx;
          for ( i = 0; i < strlen(Response); i++)
          {
            idx = strstr_regex(Response, "X+"); 
            if (idx !=-1)
            {
              Response[idx]=byteString[idx];
            // write("%c",buffer[idx]);
            }
          }
          toUpper(Response,Response,strlen(Response) );
          
          write("buff %s",Response);
          
          
          write("buff2 %s",byteString);
        
    			if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
    			{
    				TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
    				return 1;
    			}
          else
    			{
    				TestStepFail("INFO","Unexpected %s received!", MessageFormat);
    				return 0;
    			}
      }


     }

		//Message received, Compare mode is not equal
		else if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)) || 0 == strncmp("NotEqual_Regexp", CompareMode, strlen(CompareMode)))
		{
			if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)))
			{
				if(0 != strncmp(byteString, Response, strlen(Response)) || strlen(byteString) != strlen(Response))
				{
					TestStepPass("INFO","Not equal %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{
					TestStepFail("INFO","Unexpected equal %s is received!", MessageFormat);
					return 0;
				}
			}
			else
			{
				if(0 == str_match_regex(byteString, Response))
				{
					TestStepPass("INFO","Wrong substring in %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{
					TestStepFail("INFO","Unexpected %s with correct substring received!", MessageFormat);
					return 0;
				}
			}
		}
		//Message received, Compare mode is suppressed (equal or regexp)
		else if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp("response", MessageFormat,strlen(MessageFormat)))
			{
				if(NumberRPs > 0)
				{
					if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
					{
						if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
						{
							TestStepPass("INFO","Expected %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","Unexpected %s received after response pending!", MessageFormat);
							return 0;
						}
					}
					else
					{
						if(1 == str_match_regex(byteString, Response))
						{
							TestStepPass("INFO","Expected substring in %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","There is not expected substring after response pending in %s!", MessageFormat);
							return 0;
						}
					}
				}
				else
				{
					TestStepFail("INFO","Response received without response pending!");
					return 0;
				}
			}
			else
			{
				if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
				{
					if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
					{
						TestStepPass("INFO","Expected %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","Unexpected %s received!", MessageFormat);
						return 0;
					}
				}
				else
				{
					if(1 == str_match_regex(byteString, Response))
					{
						TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","There is not expected substring in %s!", MessageFormat);
						return 0;
					}
				}
			}
		}
    
		//Message received, Compare mode is regexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{
			if(1 == str_match_regex(byteString, Response))
			{
				TestStep("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStep("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
    
		//Message received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepFail("INFO","Response arrived but it was NOT expected!");
			return 0;
		}
	}
	else
	{
		//Message does not received, Compare mode is suppressed (equal or regexp)
		if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(NumberRPs == 0)
			{
				TestStepPass("INFO","No response pending and no response are received as expected!");
				return 1;
			}
			else
			{
				TestStepFail("INFO","No response is received after response pending!");
				return 0;
			}
		}
		//Message does not received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepPass("INFO","Response did not arrive as expected!");
			return 1;
		}
		//Message does not received, Compare mode is not supported here
		else
		{
			TestStepFail("INFO","Timeout while waiting for diag response");
			return 0;
		}
	}
}

//- -----------------------------------------------------------------------------------------------

/*This function is called internally for evaluating bits in response byte*/

int Bits_Evaluation(int Byte_Position,char Bits_data[])
{
  int i,j=0;
  byte data=0x00,data1= 0x00;
  
  for (i=7;i>=0;i--)
  {
    j++;
    if(Bits_data[i]=='X')
    {
      data1 = 0x01 << (j-1);
      if( data1 & RsRxIntData[Byte_Position])
        Bits_data[i]='1';
      else
        Bits_data[i]='0';
     }
      data1=0;
    
      write(" bits_data[%i]=%x",i,Bits_data[i]);
      if (Bits_data[i]!='0')
        data |= 1 <<  (j-1);
    
  }
  j=0;
  i=0;
  
  write(" RsRxIntData =%x  and expected data =%x",RsRxIntData[Byte_Position],data);
  
  if(data == RsRxIntData[Byte_Position])
  {
    data=0x00;
    return 1;
  }
  else
  {
    data=0x00;
    return 0;
  }
 
}

//int Bits_Evaluation(int Byte_Position,char Bits_data[])
//{
//  int i,j=0;
//  byte data=0x00;
//  for (i=7;i>=0;i--)
//  {
//    
//    
//    if(Bits_data[i]!='X')
//    {
//      if (Bits_data[i]!='0')
//        data = (data |  Bits_data[i]) << i;
//      write(" bits_data[%i]=%x",i,Bits_data[i]);
//    }
//
//  }
//  
//  if(data == RsRxIntData[Byte_Position])
//  {
//    write("value of data  = %x ,recieved data =%x",data,RsRxIntData[Byte_Position]);
//    return 1;
//    
//  }
//  else
//  {
//    write("value of data  = %x ,recieved data =%x",data,RsRxIntData[Byte_Position]);
//    return 0;
//    
//  }
// 
//}


//- -----------------------------------------------------------------------------------------------

/*This function is called internally for evaluating bits in response byte*/

int Byte_Evaluation(int Byte_Position, byte Byte_data)
{
  
  if(Byte_data == RsRxIntData[Byte_Position])
  {
    return 1;
  }
  else
  {
    return 0;
  }
 
}

/*This function is called internally for evaluating bytes in response bytes*/

int Multiple_Bytes_Evaluation(int Start_Position,int End_Position, char Bytes_data[])
{
  
    int i,j,Resut_Flag=0;
    char c1,c2;
    int strIndex;
    char RscheckStringData[8194];
    byte RscheckData[8194];

    strIndex = 0;
    str_replace_regex(Bytes_data, " ", "");
    for (i = 0; i < elcount(RscheckStringData); i++)
      {
          RscheckStringData[i] = 0;
      }
    
    for (i = 0; i < strlen(Bytes_data); i++)
     {
      RscheckStringData[i] = Bytes_data[i];     
     }
      RscheckStringData[i] = Bytes_data[i];     
     
   
    for (i = 0; i < (strlen(RscheckStringData)/2); i++)
    {
        strIndex = i * 2;

        c1 = RscheckStringData[strIndex];
        c2 = RscheckStringData[strIndex + 1];
        //write ("Here is c1: %c and c2: %c", c1, c2);
        RscheckData[i] = char2byte(c1, 16) + char2byte(c2, 1);    
         
    }
    j=0;
    for (i=Start_Position;i<=End_Position;i++)
    {
      //write("***%x****",RscheckData[j]);
      //write("***%x****",RsRxIntData[i]);
      if (RsRxIntData[i] == RscheckData[j])
      {
        Resut_Flag=1;
      }
      else
      {
        Resut_Flag=0;
      }
      j++;
    }
   
    if (Resut_Flag ==1)
    {
      return 1;
    }
    else
    {
      return 0;
    }
 
}

/*This function is called from design for evaluating bits in response byte*/

export void Bits_Data_Verification(char Request[], char Response[],int Position,char Bits[], char AddressingMode[])
{
  int i;
  long result;
  str_replace_regex(Bits, " ", "");
  if (strlen(Bits)==8)
  {
    Byte_Position = Position-1;
    for (i=0; i<8;i++)
    {
      Bits_Evaluation[i] = Bits[i];
      
    }
    result=RequestResponseCompareLogic(Request,Response,"Bits_Evaluation",AddressingMode);
  }
  else
  {
    TestStepFail("INFO","Bits size not correct");
  }  
  
}

/*This function is called from design for evaluating particular byte in response bytes*/

export void Byte_Data_Verification(char Request[], char Response[],int Position,byte Byte_data, char AddressingMode[])
{
  int i;
  long result;
  
  Byte_Position = Position;
  Byte_value=Byte_data;
  result=RequestResponseCompareLogic(Request,Response,"Byte_Evaluation",AddressingMode);
  
}

/*This function is called from design for evaluating bytes in response bytes*/

export void Multiple_Bytes_Data_Verification(char Request[], char Response[],int Start_Position,int End_Position,char Bytes_data[], char AddressingMode[])
{
  int i;
  long result;
  
  Start_value = Start_Position;
  End_value = End_Position;
  
  strncpy(Bytes_value, Bytes_data, strlen(Bytes_data)+1);
  
  result=RequestResponseCompareLogic(Request,Response,"Bytes_Evaluation",AddressingMode);
  
}

/*This function is called from Design for sending Diag Request with Address Mode as Physical or Functional and when 
Response is received Comparison is done with Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed */

export testfunction TF_RequestResponseCompareLogic(char Request[], char Response[], char CompareMode[], char AddressingMode[])
{
  long result;
  result = RequestResponseCompareLogic(Request, Response, CompareMode, AddressingMode);
  testWaitForTimeout(500);
}
export testfunction TF_SecurityAccess(char Request[], char Response[], char CompareMode[], char AddressingMode[])
 {
dword Keyw,Saved_Key,tempkey1,tempkey2,tempkey3,tempkey4,tempkey5,seed,RN4H, RN4L;
    long timeOutValue;
    int numberRPs;
    int getData;
    int i = 0;
    long ext_Id = 0x80000000;  
int SC4 = 0xD9;
seed=0;
Keyw=0;
tempkey1=0;
tempkey2=0;
tempkey3=0;
tempkey4=0;
tempkey5=0;             
  
  if(RsRxIntData[0] == 0x67 && RsRxIntData[1] == 0x41)
              {
                  if(RsRxIntData[6]==0x00)
                {
                  RsRxIntData[6]=RsRxIntData[6]+0x23;
                }
                  if(RsRxIntData[5]==0x00)
                {
                  RsRxIntData[5]=RsRxIntData[5]+0x23;
                }
                  if(RsRxIntData[4]==0x00)
                {
                  RsRxIntData[4]=RsRxIntData[4]+0x23;
                }
                  if(RsRxIntData[3]==0x00)
                {
                  RsRxIntData[3]=RsRxIntData[3]+0x23;
                }

          seed = ((RsRxIntData[6] & 0x000000FF) | ((RsRxIntData[5] & 0x000000FF) << 0x08) | ((RsRxIntData[4] & 0x000000FF) << 0x10) | ((RsRxIntData[3] & 0x000000FF) << 0x18));
         // write("%X",seed);
    
         tempkey1 = (seed + 0xAEFC2A98);

         tempkey2 = ((tempkey1 << 1) | (tempkey1 >> (0x20 - 1)));
         tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));
         tempkey2 = ((tempkey2 << 1) | (tempkey2 >> (0x20 - 1)));

         tempkey3 = ((seed >> 1) | (seed << (0x20 - 1)));


         tempkey4 = tempkey2 ^ tempkey3;
    
         RN4H = ((seed & 0xFFFF0000) >> 0x10);

         RN4L = (seed & 0x0000FFFF);

         tempkey5 = (RN4H * RN4L);

         Keyw =((tempkey4 ^ tempkey5) + 0x00703714);
         RqTxData[0]=0x27;
         RqTxData[0]=0x42;
         RqTxData[2] = ((Keyw & 0xFF000000) >> 0x18);
         RqTxData[3] = ((Keyw & 0x00FF0000) >> 0x10);
         RqTxData[4] = ((Keyw & 0x0000FF00) >> 0x08);
         RqTxData[5] = (Keyw & 0x000000FF);
         RqTxData[6] = 0xEA;
         write("i am inside security");
         CanTpSendData(0, RqTxData, 7);
         CanTpCloseConnection( 0 );
       }
}

/*This function is called from design for evaluating bits in response byte*/

export testfunction TF_Bits_Data_Verification(char Request[], char Response[],int Position,char Bits[], char AddressingMode[])

{
  Bits_Data_Verification(Request, Response,Position,Bits, AddressingMode);
}

/*This function is called from design for evaluating byte in response bytes*/

export testfunction TF_Byte_Data_Verification(char Request[], char Response[],int Position,int Byte_data, char AddressingMode[])

{
  Byte_Data_Verification(Request, Response,Position,Byte_data, AddressingMode);
}

/*This function is called from design for evaluating bytes in response bytes*/

export testfunction TF_Multiple_Bytes_Data_Verification(char Request[], char Response[],int Start_Position,int End_Position,char Bytes_data[], char AddressingMode[])

{
  Multiple_Bytes_Data_Verification(Request, Response,Start_Position,End_Position,Bytes_data, AddressingMode);
}

//- -----------------------------------------------------------------------------------------------

/*This function is called internally to convert Character array to Byte array*/

void CharArray2Byte(char convertable_array[])
{
    int i;
    char c1,c2;
    int strIndex;

    strIndex = 0;
    
    for (i = 0; i < elcount(RqTxStringData); i++)
      {
          RqTxStringData[i] = 0;
      }
    
    for (i = 0; i < strlen(convertable_array); i++)
     {
      RqTxStringData[i] = convertable_array[i];     //RqTxStringData is a global variable
     }
    
    ByteSize = 0;  //ByteSize is a global variable
    for (i = 0; i < (strlen(RqTxStringData)/2); i++)
    {
        strIndex = i * 2;

        c1 = RqTxStringData[strIndex];
        c2 = RqTxStringData[strIndex + 1];
//        write ("Here is c1: %c and c2: %c", c1, c2);
        RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);     // RqTxData is a global variable
        //write("%x",RqTxData[i]);
        ByteSize++;
    }
    SID = RqTxData[0];
}

//- -----------------------------------------------------------------------------------------------

/*This function is called internally to add space between two characters*/

void CharArraywithspace(char convertable_array[])
{
    int i, j, k;
   

    for (i = 0; i < strlen(convertable_array); i++)
     {
        if (i%2 ==1)
        {
            Rs_withspace[j] = convertable_array[i];
          Rs_withspace[j+1] = ' ';
          j+=2;
        }
        else
        {
            Rs_withspace[j] = convertable_array[i];
            j++;
        }
    }
  //write("RqRs_withspace, %s", RqRs_withspace);

}

//- -----------------------------------------------------------------------------------------------

/*This function is called internally to convert character to byte*/

byte char2byte (char c, int factor)
{
    switch(c){
    case 'F': 
    case 'f': return 15 * factor;
    case 'E':
    case 'e': return 14 * factor;
    case 'D':
    case 'd': return 13 * factor;
    case 'C':
    case 'c': return 12 * factor;
    case 'B':
    case 'b': return 11 * factor;
    case 'A':
    case 'a': return 10 * factor;
    case '9': return 9 * factor;
    case '8': return 8 * factor;
    case '7': return 7 * factor;
    case '6': return 6 * factor;
    case '5': return 5 * factor;
    case '4': return 4 * factor;
    case '3': return 3 * factor;
    case '2': return 2 * factor;
    case '1': return 1 * factor;
    }
    return 0;
}

//- -----------------------------------------------------------------------------------------------

/*This function is called from design to change to different Diag Sessions */
//export testfunction TF_WriteSystemVariable(char SysVarName[], double value)
//{
//  char sysvar_namespace[255], sysvar_variable[255];
//  int idx = -2, saved_index = 0, status, type;
//  
//  while (idx != -1)
//  {
//     saved_index++;
//     idx = strstr_off(SysVarName,saved_index,"::");
//     if(idx != -1)
//     {
//      saved_index = idx;
//     }
//  }
// 
//  for(idx = 0;idx < saved_index - 1; idx++)
//  {
//    sysvar_namespace[idx] = SysVarName[idx];
//  }
//  sysvar_namespace[idx] = '\0';
// 
//  idx = 0;
//  for(saved_index = saved_index + 1; saved_index < strlen(SysVarName); saved_index++)
//  {
//    sysvar_variable[idx] = SysVarName[saved_index];
//    idx++;
//  } 
//
//  /*Set the XCP variables which correspnds to be tested*/
//  teststep("","Set %s::%s to value %lf",sysvar_namespace,sysvar_variable,value);
//  
////  type = sysGetVariableSVType(lookupSysvar(sysvar_namespace,sysvar_variable));
////  
////  if(type == 0)
////  {
////    testStepErrorInTestSystem("","XCP Variable %s::%s not found",sysvar_namespace,sysvar_variable);
////    return;
////  }
////  else if(type == 1)
////  {
////    status = sysSetVariableFloat(sysvar_namespace, sysvar_variable, value);
////  }
////  else if(type == 2)
////  {
////    status = sysSetVariableInt(sysvar_namespace, sysvar_variable, (int)value);
////  }
////  else if(type == 6)
////  {
////    status = sysSetVariableInt(sysvar_namespace, sysvar_variable, (int64)value);
////  }
////  
////  if(status == 0)
////  {
////    testStepPass("","XCP Variable %s::%s is %lf ", sysvar_namespace, sysvar_variable, value);
////  }
////  else
////  {
////    testStepfail("", "XCP Variable %s::%s is not written,Error code number is %lf ", sysvar_namespace, sysvar_variable, status);
////  }
// 
//}

//export testfunction TF_ReadSystemVariable(char SysVarName[], double ExpectedValue)
//{
//  char sysvar_namespace[255], sysvar_variable[255];
//  int idx = -2, saved_index = 0, status, type, val_int;
//  double val_double;
//  int64 val_longlong;
//  
//  while (idx != -1)
//  {
//     saved_index++;
//     idx = strstr_off(SysVarName,saved_index,"::");
//     if(idx != -1)
//     {
//      saved_index = idx;
//     }
//  }
// 
//  for(idx = 0;idx < saved_index - 1; idx++)
//  {
//    sysvar_namespace[idx] = SysVarName[idx];
//  }
//  sysvar_namespace[idx] = '\0';
// 
//  idx = 0;
//  for(saved_index = saved_index + 1; saved_index < strlen(SysVarName); saved_index++)
//  {
//    sysvar_variable[idx] = SysVarName[saved_index];
//    idx++;
//  } 
//
//  /*Set the XCP variables which correspnds to be tested*/
//  teststep("","Read %s::%s",sysvar_namespace,sysvar_variable);
//  
////  type = sysGetVariableSVType(lookupSysvar(sysvar_namespace,sysvar_variable));
////  
////  if(type == 0)
////  {
////    testStepErrorInTestSystem("","XCP Variable %s::%s not found",sysvar_namespace,sysvar_variable);
////    return;
////  }
////  else if(type == 1)
////  {
////    status = sysSetVariableFloat(sysvar_namespace, sysvar_variable, val_double);
////  }
////  else if(type == 2)
////  {
////    status = sysSetVariableInt(sysvar_namespace, sysvar_variable, val_int);
////    val_double = val_int;
////  }
////  else if(type == 6)
////  {
////    status = sysSetVariableLongLong(sysvar_namespace, sysvar_variable, val_longlong);
////    val_double = val_longlong;
////  }
//  
////  if(status == 0)
////  {
////    if((int)((val_double - ExpectedValue)*1000000) == 0)
////    {
////      testStepPass("","XCP Variable %s::%s is %lf ", sysvar_namespace, sysvar_variable, val_double);
////    }
////    else
////    {
////      testStepfail("", "XCP Variable %s::%s = %lf, does not have expected value %lf", sysvar_namespace, sysvar_variable, val_double,ExpectedValue);
////    }
////  }
////  else
////  {
////    testStepfail("", "XCP Variable %s::%s is not written,Error code number is %d ", sysvar_namespace, sysvar_variable, status);
////  }
// 
//}
void Signal_Physical_Value_Check(char BusSignal[], double factor, double offset, double expectedRawValue)
{
  double TestValue =-1,calculatedValue = -1;
  
  TestValue = getSignal(BusSignal);
  testStep("","Signal %s has value = %lf",BusSignal, TestValue);
  calculatedValue = (double)( expectedRawValue * factor) + offset;
  
  if(calculatedValue == TestValue)
  {
    testStepPass("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
  }
  else if((calculatedValue < 0) && (calculatedValue >- 1))
  {
    if(TestValue < calculatedValue)
    {
      if(TestValue > (0.95 * calculatedValue))
      {
        testStepPass("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
      }
      else
      {
        testStepFail("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
      }
    }
    else if(TestValue > calculatedValue)
    {
      if(TestValue < (1.05 * calculatedValue))
      {
        testStepPass("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
      }
      else
      {
        testStepFail("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
      }
    }
    else
    {
      testStepFail("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
    }
  }
  else
  {
    testStepFail("","Expected Value = %lf, Obtained Value = %lf",calculatedValue, TestValue);
  }
}

//export testfunction TF_Signal_Physical_Value_Check(char BusSignal[], double factor, double offset, double expectedRawValue)
//{
//  Signal_Physical_Value_Check(BusSignal, factor, offset, expectedRawValue);
//}
export testfunction DiagSessionCtrl (char sessionName[])
{
	if(0 == strncmp("Default", sessionName, strlen(sessionName)))
	{
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1001", "5001.*", "Regexp","Physical");
    }
    else if(0 == strncmp("Extended", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1003", "5003.*", "Regexp","Physical");
    }
    else if(0 == strncmp("Programming", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1002", "5002.*", "Regexp","Physical");
    }
	else if(0 == strncmp("RBEOL", sessionName, strlen(sessionName)))
	{
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("80fa31033005", "c0fa", "Equal","Physical");
		RequestResponseCompareLogic("80fa1108", "c0fa00", "Equal","Physical");
	}
    else
    {
		TestStepFail("INFO","The sessionName is not valid!");
		TestStepFail("INFO","Please choose from the following sessionName types: Default, Extended, Programming!");
    }
    //putvalue(EnvTesterPresentOnOff,1);
}